<# // Copyright (c) IxMilia.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information. #>
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ output extension=".cs" #>
<#@ include file="$(ProjectDir)\MultipleOutputHelper.t4" #>
<#
var manager = Manager.Create(Host, GenerationEnvironment);
var xml = XDocument.Load(this.Host.ResolvePath(@"EntitiesSpec.xml")).Root;
var xmlns = xml.Name.NamespaceName;
var entities = xml.Elements(XName.Get("Entity", xmlns)).Where(x => x.Attribute("Name").Value != "DxfEntity");
#>
<# manager.StartHeader(); #>
// Copyright (c) IxMilia.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

// The contents of this file are automatically generated by a tool, and should not be directly modified.

using System;
using System.Collections.Generic;
using System.Linq;
using IxMilia.Dxf.Collections;

namespace IxMilia.Dxf.Entities
{

<# manager.EndBlock(); #>
    public enum DxfEntityType
    {
<#
var enumNames = new HashSet<string>();
foreach (var entity in entities.OrderBy(e => EntityType(e)))
{
    var entityType = EntityType(entity);
    if (!string.IsNullOrEmpty(entityType) && !enumNames.Contains(entityType))
    {
        enumNames.Add(entityType);
#>
        <#= entityType #>,
<#
    } // if
} // foreach entity
#>
    }

<#
var baseEntity = xml.Elements(XName.Get("Entity", xmlns)).Where(x => Name(x) == "DxfEntity").Single();
#>
    /// <summary>
    /// DxfEntity class
    /// </summary>
    public partial class DxfEntity : IDxfItemInternal
    {
        uint IDxfItemInternal.Handle { get; set; }
        uint IDxfItemInternal.OwnerHandle { get; set; }
        public IDxfItem Owner { get; private set;}

        void IDxfItemInternal.SetOwner(IDxfItem owner)
        {
            Owner = owner;
        }

<#

//
// Pointers
//
var pointers = GetPointers(baseEntity);
if (pointers.Any())
{
#>
        IEnumerable<DxfPointer> IDxfItemInternal.GetPointers()
        {
<#
    foreach (var pointer in pointers)
    {
#>
            yield return <#= Name(pointer) #>Pointer;
<#
    } // foreach pointer
#>
        }

        IEnumerable<IDxfItemInternal> IDxfItemInternal.GetChildItems()
        {
            return ((IDxfItemInternal)this).GetPointers().Select(p => (IDxfItemInternal)p.Item);
        }
<#

    foreach (var pointer in pointers)
    {
#>
        internal DxfPointer <#= Name(pointer) #>Pointer { get; } = new DxfPointer();
<#
    }
#>

<#
} // end if pointers.Any()

//
// Properties
//
foreach (var property in GetPropertiesAndPointers(baseEntity))
{
    var typeString = Type(property);
    if (AllowMultiples(property))
    {
        typeString = string.Format("List<{0}>", typeString);
    }

    var getset = string.Format("{{ get; {0}set; }}", SetterAccessibility(property));
    if (IsPointer(property))
    {
        getset = string.Format("{{ get {{ return {0}.Item as {1}; }} set {{ {0}.Item = value; }} }}", Name(property) + "Pointer", typeString);
    }
#>
        public <#= typeString #> <#= Name(property) #> <#= getset #>
<#
} // foreach property
#>

        public string EntityTypeString
        {
            get
            {
                switch (EntityType)
                {
<#
foreach (var entity in entities)
{
    var typeString = TypeString(entity);
    var commaIndex = typeString.IndexOf(',');
    if (commaIndex >= 0)
        typeString = typeString.Substring(0, commaIndex);
    if (!string.IsNullOrEmpty(typeString))
    {
#>
                    case DxfEntityType.<#= EntityType(entity) #>:
                        return "<#= typeString #>";
<#
    } // if
} // foreach entity
#>
                    default:
                        throw new NotImplementedException();
                }
            }
        }

        protected DxfEntity(DxfEntity other)
            : this()
        {
            ((IDxfItemInternal)this).Handle = ((IDxfItemInternal)other).Handle;
            ((IDxfItemInternal)this).OwnerHandle = ((IDxfItemInternal)other).OwnerHandle;
            ((IDxfItemInternal)this).SetOwner(((IDxfItemInternal)other).Owner);
<#
foreach (var property in GetPropertiesAndPointers(baseEntity))
{
    var name = Name(property);
    if (IsPointer(property))
    {
        name += "Pointer";
#>
            this.<#= name #>.Handle = other.<#= name #>.Handle;
            this.<#= name #>.Item = other.<#= name #>.Item;
<#
    }
    else
    {
#>
            this.<#= name #> = other.<#= name #>;
<#
    }
} // foreach property
#>
        }

        protected virtual void Initialize()
        {
<#
foreach (var property in GetProperties(baseEntity))
{
    var defaultValue = AllowMultiples(property)
        ? string.Format("new List<{0}>()", Type(property))
        : DefaultValue(property);
#>
            this.<#= Name(property) #> = <#= defaultValue #>;
<#
} // foreach property
#>
        }

        protected virtual void AddValuePairs(List<DxfCodePair> pairs, DxfAcadVersion version, bool outputHandles)
        {
            pairs.Add(new DxfCodePair(0, EntityTypeString));
<#
            foreach (var line in GetWriteCommands(baseEntity))
            {
                if (string.IsNullOrWhiteSpace(line))
                {
#>

<#
                }
                else
                {
#>
            <#= line #>
<#
                }
            } // foreach
#>
        }

        internal virtual bool TrySetPair(DxfCodePair pair)
        {
            switch (pair.Code)
            {
                case 5:
                    ((IDxfItemInternal)this).Handle = UIntHandle(pair.StringValue);
                    break;
                case 330:
                    ((IDxfItemInternal)this).OwnerHandle = UIntHandle(pair.StringValue);
                    break;
<#
        foreach (var propertyGroup in GetPropertiesAndPointers(baseEntity).Where(p => !ProtectedSet(p)).GroupBy(p => Code(p)).OrderBy(p => p.Key))
        {
            var code = propertyGroup.Key;
            if (propertyGroup.Count() == 1)
            {
                var property = propertyGroup.Single();
                var name = Name(property);
                var codes = GetCodeOverrides(property);
                if (codes != null)
                {
                    var suffix = 'X';
                    for (int i = 0; i < codes.Length; i++, suffix++)
                    {
#>
                case <#= codes[i] #>:
                    this.<#= name #>.<#= suffix #> = pair.DoubleValue;
                    break;
<#
                    } // for
                } // if
                else
                {
                    if (IsPointer(property)) name += "Pointer.Handle";
                    var codeType = DxfCodePair.ExpectedType(code);
                    var codeTypeValue = TypeToString(codeType);
                    var assignCode = AllowMultiples(property)
                        ? string.Format("this.{0}.Add(", name)
                        : string.Format("this.{0} = ", name);
                    var assignSuffix = AllowMultiples(property)
                        ? ")"
                        : "";
#>
                case <#= code #>:
                    <#= assignCode #><#= ReadConverter(property) #>(pair.<#= codeTypeValue #>)<#= assignSuffix #>;
                    break;
<#
                } // else
            } // if one property per code
            else
            {
#>
                case <#= code #>:
                    // TODO: code is shared by properties <#= string.Join(", ", propertyGroup.Select(p => Name(p))) #>
                    break;
<#
            } // else multiple properties per code
        } // foreach property
#>
                default:
                    return false;
            }

            return true;
        }

        internal static DxfEntity FromBuffer(DxfCodePairBufferReader buffer)
        {
            var first = buffer.Peek();
            buffer.Advance();
            DxfEntity entity;
            switch (first.StringValue)
            {
<#
foreach (var entity in entities)
{
    var typeString = TypeString(entity);
    if (!string.IsNullOrEmpty(typeString))
    {
        var typeStrings = typeString.Split(',');
        foreach (var singleTypeString in typeStrings)
        {
#>
                case "<#= singleTypeString #>":
<#
        } // foreach
#>
                    entity = new <#= Name(entity) #>();
                    break;
<#
    } // if
} // foreach entity
#>
                default:
                    SwallowEntity(buffer);
                    entity = null;
                    break;
            }

            if (entity != null)
            {
                entity = entity.PopulateFromBuffer(buffer);
            }

            return entity;
        }
    }

    public partial class DxfDimensionBase
    {
        protected override DxfEntity PostParse()
        {
            DxfDimensionBase newDimension = null;
            switch (DimensionType)
            {
<#
foreach (var entity in entities.OrderBy(e => EntityType(e)).Where(e => BaseClass(e, "DxfEntity") == "DxfDimensionBase"))
{
#>
                case DxfDimensionType.<#= Tag(entity) #>:
                    newDimension = new <#= Name(entity) #>(this);
                    break;
<#
}
#>
            }

            if (newDimension != null)
            {
                foreach (var pair in ExcessCodePairs)
                {
                    newDimension.TrySetPair(pair);
                }
            }

            return newDimension;
        }
    }

}

<#
foreach (var entity in entities)
{
    var className = Name(entity);
    var baseClass = BaseClass(entity, "DxfEntity");
    if (GetPointers(entity).Any()) baseClass += ", IDxfItemInternal";
    manager.StartNewFile(className + "Generated.cs");
#>
    /// <summary>
    /// <#= className #> class
    /// </summary>
    public partial class <#= className #> : <#= baseClass #>
    {
        public override DxfEntityType EntityType { get { return DxfEntityType.<#= EntityType(entity) #>; } }
<#
    // min and max entity supported versions
    var minVersion = MinVersion(entity);
    if (minVersion != null)
    {
#>
        protected override DxfAcadVersion MinVersion { get { return DxfAcadVersion.<#= minVersion #>; } }
<#
    } // if

    var maxVersion = MaxVersion(entity);
    if (maxVersion != null)
    {
#>
        protected override DxfAcadVersion MaxVersion { get { return DxfAcadVersion.<#= maxVersion #>; } }
<#
    } // if

#>

<#

    //
    // Pointers
    //
    pointers = GetPointers(entity);
    if (pointers.Any())
    {
#>

        IEnumerable<DxfPointer> IDxfItemInternal.GetPointers()
        {
<#
        foreach (var pointer in pointers)
        {
            if (AllowMultiples(pointer))
            {
#>
            foreach (var pointer in <#= Name(pointer) #>Pointers.Pointers)
            {
                yield return pointer;
            }
<#
            }
            else
            {
#>
            yield return <#= Name(pointer) #>Pointer;
<#
            }
        }
#>
        }

        IEnumerable<IDxfItemInternal> IDxfItemInternal.GetChildItems()
        {
            return ((IDxfItemInternal)this).GetPointers().Select(p => (IDxfItemInternal)p.Item);
        }

<#

        foreach (var pointer in pointers)
        {
            var defaultValue = "new DxfPointer()";
            var typeString = "DxfPointer";
            var suffix = "Pointer";
            if (AllowMultiples(pointer))
            {
                var type = Type(pointer);
                defaultValue = string.Format("new DxfPointerList<{0}>()", type);
                typeString = string.Format("DxfPointerList<{0}>", type);
                suffix += "s";
            }
#>
        internal <#= typeString #> <#= Name(pointer) #><#= suffix #> { get; } = <#= defaultValue #>;
<#
        } // foreach pointer
#>

<#
    } // end if pointers.Any()

    //
    // Properties
    //
    foreach (var property in GetPropertiesAndPointers(entity))
    {
        var propertyType = Type(property);
        var getset = string.Format("{{ get; {0}set; }}", SetterAccessibility(property));
        if (IsPointer(property))
        {
            if (AllowMultiples(property))
            {
                getset = string.Format("{{ get {{ return {0}Pointers; }} }}", Name(property));
            }
            else
            {
                getset = string.Format("{{ get {{ return {0}Pointer.Item as {1}; }} set {{ {0}Pointer.Item = value; }} }}", Name(property), propertyType);
            }
        }

        if (AllowMultiples(property))
        {
            propertyType = string.Format("IList<{0}>", propertyType);
        }
#>
        <#= Accessibility(property) #> <#= propertyType #> <#= Name(property) #> <#= getset #>
<#
    } // foreach property

    foreach (var property in GetProperties(entity))
    {
        var flags = property.Elements(XName.Get("Flag", xmlns));
        if (flags.Any())
        {
#>

        // <#= Name(property) #> flags
<#
            foreach (var flag in flags)
            {
#>

        public bool <#= Name(flag) #>
        {
            get { return DxfHelpers.GetFlag(<#= Name(property) #>, <#= Mask(flag) #>); }
            set
            {
                var flags = <#= Name(property) #>;
                DxfHelpers.SetFlag(value, ref flags, <#= Mask(flag) #>);
                <#= Name(property) #> = flags;
            }
        }
<#
            } // foreach flag
        } // if
    } // foreach property

    if (HasXData(entity))
    {
#>
        public DxfXData XData { get { return ((IDxfHasXDataHidden)this).XDataHidden; } set { ((IDxfHasXDataHidden)this).XDataHidden = value; } }
<#
    }

    var defaultConstructorType = DefaultConstructor(entity);
    if (defaultConstructorType != null)
    {
        //
        // Default constructor
        //
#>

        <#= defaultConstructorType #> <#= className #>()
            : base()
        {
        }

<#
    } // if (defaultConstructorType != null)

    var constructors = entity.Elements(XName.Get("Constructor", xmlns));
    if (constructors.Any())
    {
#>
        //
        // Parameterized constructors
        //
<#
        foreach (var constructor in constructors)
        {
            var parameters = constructor.Elements(XName.Get("ConstructorParameter", xmlns));
            var argList = new List<string>();
            foreach (var parameter in parameters)
            {
                var paramName = CamlCase(Property(parameter));
                var paramType = Type(parameter);
                argList.Add(paramType + " " + paramName);
            }

            var sig = string.Join(", ", argList);
#>
        public <#= className #>(<#= sig #>)
            : this()
        {
<#
            foreach (var parameter in parameters)
            {
#>
            this.<#= Property(parameter) #> = <#= CamlCase(Property(parameter)) #>;
<#
            } // foreach parameter
#>
        }

<#
        } // foreach constructor
    } // if

    //
    // Copy constructor
    //
    var copyConstructorAccessibility = CopyConstructor(entity);
    if (copyConstructorAccessibility != null)
    {
        if (copyConstructorAccessibility == "inherited")
        {
#>
        internal <#= className #>(<#= BaseClass(entity, "DxfEntity") #> other)
            : base(other)
        {
        }
<#
        }
        else
        {
#>
        <#= copyConstructorAccessibility #> <#= className #>(<#= className #> other)
            : base(other)
        {
<#
        foreach (var property in GetPropertiesAndPointers(entity))
        {
            var name = Name(property);
            if (IsPointer(property))
            {
                name += "Pointer";
#>
            this.<#= name #>.Handle = other.<#= name #>.Handle;
            this.<#= name #>.Item = other.<#= name #>.Item;
<#
            }
            else
            {
#>
            this.<#= name #> = other.<#= name #>;
<#
            }
        } // foreach property
#>
        }
<#
        } // else
#>

<#
    } // copyConstructorAccessibility != null
#>
        protected override void Initialize()
        {
            base.Initialize();
<#
        if (BaseClass(entity, "") == "DxfDimensionBase")
        {
#>
            this.DimensionType = DxfDimensionType.<#= Tag(entity) #>;
<#
        }

        foreach (var property in GetProperties(entity))
        {
            var defaultValue = AllowMultiples(property)
                ? string.Format("new List<{0}>()", Type(property))
                : DefaultValue(property);
#>
            this.<#= Name(property) #> = <#= defaultValue #>;
<#
        } // foreach property
#>
        }

        protected override void AddValuePairs(List<DxfCodePair> pairs, DxfAcadVersion version, bool outputHandles)
        {
            base.AddValuePairs(pairs, version, outputHandles);
<#
            foreach (var line in GetWriteCommands(entity))
            {
                if (string.IsNullOrWhiteSpace(line))
                {
#>

<#
                }
                else
                {
#>
            <#= line #>
<#
                }
            } // foreach

            if (HasXData(entity))
            {
#>
            if (XData != null)
            {
                XData.AddValuePairs(pairs, version, outputHandles);
            }
<#
            }
#>
        }
<#
    if (GetPropertiesAndPointers(entity).Any() && GenerateReaderFunction(entity))
    {
#>

        internal override bool TrySetPair(DxfCodePair pair)
        {
            switch (pair.Code)
            {
<#
        foreach (var propertyGroup in GetPropertiesAndPointers(entity).Where(p => !ProtectedSet(p)).GroupBy(p => Code(p)).OrderBy(p => p.Key))
        {
            var code = propertyGroup.Key;
            if (propertyGroup.Count() == 1)
            {
                var property = propertyGroup.Single();
                var name = Name(property);
                var codes = GetCodeOverrides(property);
                if (codes != null)
                {
                    var suffix = 'X';
                    for (int i = 0; i < codes.Length; i++, suffix++)
                    {
#>
                case <#= codes[i] #>:
                    this.<#= name #>.<#= suffix #> = pair.DoubleValue;
                    break;
<#
                    } // for
                } // if
                else
                {
                    var codeType = DxfCodePair.ExpectedType(code);
                    var codeTypeValue = TypeToString(codeType);
                    if (IsPointer(property)) name += "Pointer.Handle";
                    var assignCode = AllowMultiples(property)
                        ? string.Format("this.{0}.Add(", name)
                        : string.Format("this.{0} = ", name);
                    var assignSuffix = AllowMultiples(property)
                        ? ")"
                        : "";
#>
                case <#= code #>:
                    <#= assignCode #><#= ReadConverter(property) #>(pair.<#= codeTypeValue #>)<#= assignSuffix #>;
                    break;
<#
                } // else
            } // if one property per code
            else
            {
#>
                case <#= code #>:
                    // TODO: code is shared by properties <#= string.Join(", ", propertyGroup.Select(p => Name(p))) #>
                    break;
<#
            } // else multiple properties per code
        } // foreach property
#>
                default:
                    return base.TrySetPair(pair);
            }

            return true;
        }
<#
    } // if
#>
    }

}
<#
    manager.EndBlock();
} // foreach entity

manager.Process(true);
#>
<#@ include file="$(ProjectDir)\DxfCommon.t4" #>

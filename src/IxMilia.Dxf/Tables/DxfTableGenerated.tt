<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ output extension=".cs" #>
<#
var xml = XDocument.Load(this.Host.ResolvePath(@"TableSpec.xml")).Root;
var xmlns = "http://IxMilia.com/Dxf/TableSpec";
var tables = xml.Elements(XName.Get("Table", xmlns));
#>
// The contents of this file are automatically generated by a tool, and should not be directly modified.

using System.Linq;
using System.Collections.Generic;
using IxMilia.Dxf.Sections;

namespace IxMilia.Dxf.Tables
{
<#

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                tables
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

foreach (var table in tables)
{
	var tableItem = Name(table.Element(XName.Get("TableItem", xmlns)));
#>

    public partial class Dxf<#= Type(table) #>Table : DxfTable
    {
        internal override DxfTableType TableType { get { return DxfTableType.<#= Type(table) #>; } }
        public List<<#= tableItem #>> Items { get; private set; }

        protected override IEnumerable<DxfSymbolTableFlags> GetSymbolItems()
        {
            return Items;
        }

        public Dxf<#= Type(table) #>Table()
        {
            Items = new List<<#= tableItem #>>();
        }

        internal static DxfTable ReadFromBuffer(DxfCodePairBufferReader buffer)
        {
            var table = new Dxf<#= Type(table) #>Table();
            while (buffer.ItemsRemain)
            {
                var pair = buffer.Peek();
                buffer.Advance();
                if (DxfTablesSection.IsTableEnd(pair))
                {
                    break;
                }

                if (pair.Code == 0 && pair.StringValue == DxfTable.<#= TypeString(table) #>)
                {
                    var item = <#= tableItem #>.FromBuffer(buffer);
                    table.Items.Add(item);
                }
            }

            return table;
        }
    }
<#
}
#>
}

namespace IxMilia.Dxf
{
<#

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           table items
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

foreach (var table in tables)
{
	var tableItem = table.Element(XName.Get("TableItem", xmlns));
	var properties = tableItem.Elements(XName.Get("Property", xmlns));
#>

    public partial class <#= Name(tableItem) #> : DxfSymbolTableFlags
    {
        internal const string AcDbText = "<#= ClassName(tableItem) #>";

        protected override string TableType { get { return Tables.DxfTable.<#= TypeString(table) #>; } }

        // properties
<#
	foreach (var property in properties)
	{
		var propertyType = Type(property);
		if (AllowMultiples(property))
			propertyType = string.Format("List<{0}>", propertyType);
#>
        public <#= propertyType #> <#= Name(property) #> { get; set; }
<#
	} // foreach (var property in properties)

#>

        public <#= Name(tableItem) #>()
            : base()
        {
<#
	foreach (var property in properties)
	{
		var defaultValue = DefaultValue(property);
		if (AllowMultiples(property))
			defaultValue = string.Format("new List<{0}>()", Type(property));
#>
            <#= Name(property) #> = <#= defaultValue #>;
<#
	} // foreach (var property in properties)

#>
        }

        internal override void AddValuePairs(List<DxfCodePair> pairs)
        {
            pairs.Add(new DxfCodePair(100, AcDbText));
			pairs.Add(new DxfCodePair(2, Name));
<#
	if (HasFlags(tableItem))
	{
#>
            pairs.Add(new DxfCodePair(70, (short)Flags));
<#
	} // has flags
    foreach (var property in properties)
	{
		if (AllowMultiples(property))
		{
#>
            pairs.AddRange(<#= Name(property) #>.Select(value => new DxfCodePair(<#= Code(property) #>, value)));
<#
		}
		else
		{
			var codeOverrides = CodeOverrides(property);
			if (Code(property) < 0 && codeOverrides != null)
			{
				char prop = 'X';
				for (int i = 0; i < codeOverrides.Length; i++, prop++)
				{
#>
            pairs.Add(new DxfCodePair(<#= codeOverrides[i] #>, <#= Name(property) #>.<#= prop #>));
<#
				}
			}
			else
			{
#>
            pairs.Add(new DxfCodePair(<#= Code(property) #>, <#= WriteConverter(property) #>(<#= Name(property) #>)));
<#
			}
		}
	} // foreach (var property in properties)
#>
        }

        internal static <#= Name(tableItem) #> FromBuffer(DxfCodePairBufferReader buffer)
        {
            var item = new <#= Name(tableItem) #>();
            while (buffer.ItemsRemain)
            {
                var pair = buffer.Peek();
                if (pair.Code == 0)
                {
                    break;
                }

                buffer.Advance();
                switch (pair.Code)
                {
                    case 2:
                        item.Name = pair.StringValue;
                        break;
<#
	if (HasFlags(tableItem))
	{
#>
                    case 70:
                        item.Flags = (int)pair.ShortValue;
                        break;
<#
	} // has flags
    foreach (var property in properties)
	{
		var codeOverrides = CodeOverrides(property);
		if (Code(property) < 0 && codeOverrides != null)
		{
			char prop = 'X';
			for (int i = 0; i < codeOverrides.Length; i++, prop++)
			{
				var codeType = DxfCodePair.ExpectedType(codeOverrides[i]);
				var codeTypeValue = TypeToString(codeType);
#>
                    case <#= codeOverrides[i] #>:
                        item.<#= Name(property) #>.<#= prop #> = <#= ReadConverter(property) #>(pair.<#= codeTypeValue #>);
                        break;
<#
			}
		}
		else
		{
			var code = Code(property);
			var codeType = DxfCodePair.ExpectedType(code);
			var codeTypeValue = TypeToString(codeType);
			if (AllowMultiples(property))
			{
#>
                    case <#= Code(property) #>:
                        item.<#= Name(property) #>.Add(<#= ReadConverter(property) #>(pair.<#= codeTypeValue #>));
                        break;
<#
			}
			else
			{
#>
                    case <#= Code(property) #>:
                        item.<#= Name(property) #> = <#= ReadConverter(property) #>(pair.<#= codeTypeValue #>);
                        break;
<#
			}
		}
	} // foreach (var property in properties)
#>
                }
            }

            return item;
        }
<#
#>
    }
<#
} // foreach (var table in tables)
#>
}
<#@ include file="$(ProjectDir)\DxfCommon.t4" #>
